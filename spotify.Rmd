---
title: "CS5811 Coursework"
author: "2306691, 2345478"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_notebook: default
  pdf_document: default
version: 1
---

# 0. Adding Libraries

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(VIM)          # hotdeck imputation
library(tm)           # text mining package
library(wordcloud)    # word cloud
library(forcats)      # to reverse the order of the bar plot
library(reshape2)     # to melt the correlation matrix
library(scales)       # standardize data (PCA)
library(factoextra)   # cluster analysis
library(randomForest) # random forest
library(fastDummies)  # one hot encoding
library(Metrics)
library(caret)
```


# 1. Data Cleaning

## 1.1 Data Quality Analysis

```{r}
# Reading the Most Streamed Spotify Songs 2023 Dataset
spotify <- read.csv("spotify-2023-final.csv", sep=";")

# Exploring the data set
str(spotify)
dim(spotify)
head(spotify)
```


## 1.2 Data Cleaning

```{r}
# Changing the variable names for convenience
names(spotify)[2] <- "artist_name"
names(spotify)[18] <- "danceability_perc"
names(spotify)[19] <- "valence_perc"
names(spotify)[20] <- "energy_perc"
names(spotify)[21] <- "acousticness_perc"
names(spotify)[22] <- "instrumentalness_perc"
names(spotify)[23] <- "liveness_perc"
names(spotify)[24] <- "speechiness_perc"

# Replacing empty values of categorical variables with NA
spotify$in_shazam_charts[spotify$in_shazam_charts == ""] <- NA
spotify$key[spotify$key == ""] <- NA

# Changing the variables types to conform to metadata
artist_name <- as.factor(spotify$artist_name)
spotify$artist_count <- as.factor(spotify$artist_count)
spotify$released_year <- as.factor(spotify$released_year)
spotify$released_month <- as.factor(spotify$released_month)
spotify$released_day <- as.factor(spotify$released_day)
spotify$streams <- as.numeric(spotify$streams)   # NA introduced by coercion as the value 575 was a string
spotify$in_deezer_playlists <- as.integer(gsub(",", "", spotify$in_deezer_playlists))
spotify$in_shazam_charts <- as.integer(gsub(",", "", spotify$in_shazam_charts))
spotify$key <- as.factor(spotify$key)
spotify$mode <- as.factor(spotify$mode)

# Changing the levels' names of the variable released_month for convenience
months_labels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
spotify$released_month <- factor(spotify$released_month, labels = months_labels, ordered = TRUE)

# Checking the new structure
str(spotify)
```

```{r}
# Checking some summary statistics
summary(spotify)

# Checking for missing data
colSums(is.na(spotify))         # columns 9, 14, 16

# Applying the hotdeck imputation to replace all NA values
set.seed(1234)  # to create reproducible results
hotdeck_imputation <- hotdeck(spotify)
impute_cols <- c(9,14,16)
spotify[impute_cols] <- hotdeck_imputation[impute_cols]

```


# 2. Exploratory Data Analysis (EDA)

## 2.1 Univariate analysis


```{r}
# artist_name

# Ordering the artists' names based on the frequency of songs they released on Spotify
artist_count <- sort(table(artist_name), decreasing=T)
artist_count_names <- as.character(names(artist_count))

# Selecting the 50 most frequent artists for the world cloud
artist_count_names_50 <- artist_count_names[1:50]

# Word cloud of the 50 most frequent artists' names (artists who released more songs)
wordcloud(artist_count_names_50, freq = sort(table(artist_name), decreasing=T), scale = c(3, 0.5), min.freq = 1, colors = brewer.pal(8, "Dark2"))

# Bar plot of the top 15 artist's names frequency
artist_count_15 <- head(sort(table(spotify$artist_name), decreasing=T), 15)
artist_count_15_df <- data.frame(artist_name = names(artist_count_15), n = as.numeric(artist_count_15))
ggplot(artist_count_15_df, aes(y = reorder(artist_name, n), x = n)) + 
  geom_bar(stat = "identity", fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Frequency", y = "Artist Name", title = "Top 15 Artist's Names Frequency") + 
  theme_minimal()
```

```{r}
# artist_count
table(spotify$artist_count)      # 587 songs by solo artist, 254 by 2 artists

# Bar plot of the count of artists per song
ggplot(spotify, aes(y = fct_rev(artist_count))) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Frequency", y = "Number of Artists per Song", title = "Artist's Count Frequency") +
  theme_minimal() 
```

```{r}
# released_year
table(spotify$released_year)

# Bar plot of the years of release of the songs
ggplot(spotify, aes(x = released_year)) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Year", y = "Number of Released Songs", title = "Number of Released Songs in each Year") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# released_month
table(spotify$released_month)

# Bar plot of the months of release of the songs
ggplot(spotify, aes(x = released_month)) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Month", y = "Number of Released Songs", title = "Number of Released Songs in each Month") + 
  theme_minimal() 
```

```{r}
# released_day
table(spotify$released_day)

# Bar plot of the months of release of the songs
ggplot(spotify, aes(x = released_day)) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Day", y = "Number of Released Songs", title = "Number of Released Songs in each Day") + 
  theme_minimal()
```


```{r}
# in_spotify_playlists
summary(spotify$in_spotify_playlists)

# Histogram of the distribution of the number of spotify playlists each song is 
ggplot(spotify, aes(x = in_spotify_playlists)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(in_spotify_playlists), color = "mean"), size = 1) +
  geom_vline(aes(xintercept = median(in_spotify_playlists), color = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_spotify_playlists") 

# Box plot of the distribution of the number of spotify playlists each song is 
ggplot(spotify, aes(y=in_spotify_playlists)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_spotify_playlists") + 
  coord_flip() + 
  theme_bw()
```

```{r}
# in_spotify_charts
summary(spotify$in_spotify_charts)

# Histogram of the distribution of the percentage of in_spotify_charts 
ggplot(spotify, aes(x = in_spotify_charts)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_spotify_charts), color = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_spotify_charts), color = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_spotify_charts") 

# Box plot of the distribution of the percentage of in_spotify_charts
ggplot(spotify, aes(y=in_spotify_charts)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_spotify_charts") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# in_apple_playlists
summary(spotify$in_apple_playlists)

# Histogram of the distribution of the number of apple playlists each song is 
ggplot(spotify, aes(x = in_apple_playlists)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_apple_playlists), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_apple_playlists), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_apple_playlists") 

# Box plot of the distribution of the number of apple playlists each song is 
ggplot(spotify, aes(y=in_apple_playlists)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_apple_playlists") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# in_apple_charts
summary(spotify$in_apple_charts)

# Histogram of the distribution of the number of apple charts each song is 
ggplot(spotify, aes(x = in_apple_charts)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_apple_charts), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_apple_charts), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_apple_charts") 

# Box plot of the distribution of the number of apple charts each song is 
ggplot(spotify, aes(y=in_apple_charts)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_apple_charts") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# in_deezer_playlists
summary(spotify$in_deezer_playlists)

# Histogram of the distribution of the number of deezer playlists each song is 
ggplot(spotify, aes(x = in_deezer_playlists)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_deezer_playlists), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_deezer_playlists), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_deezer_playlists") 

# Box plot of the distribution of the number of deezer playlists each song is 
ggplot(spotify, aes(y=in_deezer_playlists)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_deezer_playlists") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# in_deezer_charts
summary(spotify$in_deezer_charts)

# Histogram of the distribution of the number of deezer charts each song is 
ggplot(spotify, aes(x = in_deezer_charts)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_deezer_charts), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_deezer_charts), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_deezer_charts") 

# Box plot of the distribution of the number of deezer charts each song is 
ggplot(spotify, aes(y=in_deezer_charts)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_deezer_charts") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# in_shazam_charts
summary(spotify$in_shazam_charts)

# Histogram of the distribution of the number of shazam charts each song is 
ggplot(spotify, aes(x = in_shazam_charts)) + 
  geom_histogram(bins = 30, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$in_shazam_charts), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$in_shazam_charts), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of in_shazam_charts") 

# Box plot of the distribution of the number of shazam charts each song is 
ggplot(spotify, aes(y=in_shazam_charts)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of in_shazam_charts") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# streams (target variable)
summary(spotify$streams)

# Histogram of the distribution of the streams for each song
ggplot(spotify, aes(x = streams)) + 
  geom_histogram(bins = 50, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$streams), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$streams), colour = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of streams") + 
  scale_x_continuous(labels = label_number(suffix = " k", scale = 1e-6))

# Box plot of the distribution of the streams for each song
ggplot(spotify, aes(y=streams)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  scale_y_continuous(labels = label_number(suffix = " k", scale = 1e-6)) + 
  ggtitle("Boxplot of streams") + 
  coord_flip() + theme_bw()

# Checking the two major outliers
subset(spotify,streams>3e+09)
# Reasonable data, let's keep them
```


```{r}
# bpm
summary(spotify$bpm)

# Histogram of the distribution of the bpm of songs 
ggplot(spotify, aes(x = bpm)) + geom_histogram(binwidth = 0.5, fill = "deepskyblue4") +
  geom_vline(aes(xintercept = mean(spotify$bpm), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$bpm), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of bpm") 

# Box plot of the distribution of the bpm of songs
ggplot(spotify, aes(y=bpm)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of bpm") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# key
table(spotify$key)

# Bar plot of the key for each song
ggplot(spotify, aes(x = key)) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Key", y = "Number of Songs", title = "Number of Keys (Scale) used for each song") + 
  theme_minimal() 
```

```{r}
# mode
table(spotify$mode)

# Bar plot of the mode for each song
ggplot(spotify, aes(x = mode)) + 
  geom_bar(fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Mode", y = "Number of Songs", title = "Mode used for each song") +
  theme_minimal() 
```


```{r}
# danceability_perc
summary(spotify$danceability_perc)

# Histogram of the distribution of the percentage of danceability 
ggplot(spotify, aes(x = danceability_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$danceability_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$danceability_perc), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of danceability") 

# Box plot of the distribution of the percentage of danceability
ggplot(spotify, aes(y=danceability_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of danceability") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# valence_perc
summary(spotify$valence_perc)

# Histogram of the distribution of the percentage of valence 
ggplot(spotify, aes(x = valence_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$valence_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$valence_perc), colour = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of valence")

# Box plot of the distribution of the percentage of valence
ggplot(spotify, aes(y=valence_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of valence") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# energy_perc
summary(spotify$energy_perc)

# Histogram of the distribution of the percentage of energy 
ggplot(spotify, aes(x = energy_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$energy_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$energy_perc), colour = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of energy")

# Box plot of the distribution of the percentage of energy
ggplot(spotify, aes(y=energy_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of energy") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# acousticness_perc
summary(spotify$acousticness_perc)

# Histogram of the distribution of the percentage of acousticness 
ggplot(spotify, aes(x = acousticness_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$acousticness_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$acousticness_perc), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of acousticness") 

# Box plot of the distribution of the percentage of acousticness
ggplot(spotify, aes(y=acousticness_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of acousticness") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# instrumentalness_perc
summary(spotify$instrumentalness_perc)

# Histogram of the distribution of the percentage of instrumentalness 
ggplot(spotify, aes(x = instrumentalness_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$instrumentalness_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$instrumentalness_perc), colour = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of instrumentalness")

# Box plot of the distribution of the percentage of instrumentalness
ggplot(spotify, aes(y=instrumentalness_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of instrumentalness") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# liveness_perc
summary(spotify$liveness_perc)

# Histogram of the distribution of the percentage of liveness 
ggplot(spotify, aes(x = liveness_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") +
  geom_vline(aes(xintercept = mean(spotify$liveness_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$liveness_perc), colour = "median"), size = 1) + 
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of liveness")

# Box plot of the distribution of the percentage of liveness
ggplot(spotify, aes(y=liveness_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of liveness") + 
  coord_flip() + 
  theme_bw()
```


```{r}
# speechiness_perc
summary(spotify$speechiness_perc)

# Histogram of the distribution of the percentage of speechiness 
ggplot(spotify, aes(x = speechiness_perc)) + 
  geom_histogram(binwidth = 0.5, fill = "deepskyblue4") + 
  geom_vline(aes(xintercept = mean(spotify$speechiness_perc), colour = "mean"), size = 1) + 
  geom_vline(aes(xintercept = median(spotify$speechiness_perc), colour = "median"), size = 1) +
  scale_color_manual(name = "Statistics", values = c(median = "orange", mean = "yellow")) +
  ggtitle("Distribution of speechiness")

# Box plot of the distribution of the percentage of speechiness
ggplot(spotify, aes(y=speechiness_perc)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Boxplot of speechiness") + 
  coord_flip() + 
  theme_bw()
```


## 2.2 Multivariate analysis

stream ~ all variables:

-  two numerical variables: cor.test(), scatter plot
-  one numerical variable and one categorical variable: boxplot + diagnostic plots to check the consistency of variance and the normality of errors


```{r}
# streams ~ artist_name 

# Creating a word cloud to visualize the most streamed artists
top_artists <- spotify %>% 
  dplyr::select(artist_name, streams) %>% 
  arrange(desc(streams))

# Finding the 50 most streamed artists
top_50_artists <- top_artists %>%
  group_by(artist_name) %>%
  dplyr::summarize(total_streams = sum(streams, na.rm = TRUE)) %>%
  arrange(desc(total_streams)) %>%
  slice_head(n = 50)

# Checking the top_artists data set
str(top_artists)
summary(top_artists)

wordcloud(top_50_artists$artist_name, freq = top_50_artists$total_streams, scale = c(2.1, 0.5), min.freq = 1, colors = brewer.pal(8, "Dark2"))

top_15_artists <- top_50_artists %>%
  slice_max(order_by = total_streams, n = 15)

# Plotting the top 10 artists
ggplot(top_15_artists, aes(y = reorder(artist_name, total_streams), x = total_streams)) + 
  geom_bar(stat = "identity", fill = "honeydew", color = "black", width = 0.8) + 
  labs(x = "Frequency", y = "Artist Name", title = "Top 10 Artists By Streams") + 
  theme_minimal()
```


```{r}
# streams ~ artist_count

# numerical variable ~ categorical variable --> ANOVA
summary.lm(aov(spotify$streams~spotify$artist_count))
# The model is significant (p value < 0.05): the count of artists is associated with significant different streams, in mean.

# Diagnostic plots to check the consistency of variance and the normality of errors
plot(aov(spotify$streams~spotify$artist_count))
# There is a deviation from the line in the right side of the QQ plot.

# Box plot of streams ~ artist_count
ggplot(spotify, aes(x=artist_count, y=streams)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Box plot of streams by artist count") + 
  theme_minimal()
```


```{r}
# streams ~ released_year

# numerical variable ~ categorical variable --> ANOVA
summary.lm(aov(spotify$streams~spotify$released_year))
# The model is significant (p value < 0.05): the the number of streams significantly changes according to the released year.

# Diagnostic plots to check the consistency of variance and the normality of errors
plot(aov(spotify$streams~spotify$released_year))
# There is a deviation from the line at the ends of the QQ plot. 

# Box plot of streams ~ released_year
ggplot(spotify, aes(x=released_year, y=streams)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Box plot of streams by released year") + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```


```{r}
# streams ~ released_month

# numerical variable ~ categorical variable --> ANOVA
summary.lm(aov(spotify$streams~spotify$released_month))
# The model is significant (p value < 0.05): the the number of streams significantly changes according to the released month.

# Diagnostic plots to check the consistency of variance and the normality of errors
plot(aov(spotify$streams~spotify$released_month))
# There is a deviation from the line in the right side of the QQ plot.

# Box plot of streams ~ released_month
ggplot(spotify, aes(x=released_month, y=streams)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Box plot of streams by released month") + 
  theme_minimal()
```


```{r}
# streams ~ released_day

# numerical variable ~ categorical variable --> ANOVA
summary.lm(aov(spotify$streams~spotify$released_day))
# The model is significant (p value < 0.05): the the number of streams significantly changes according to the released day.

# Diagnostic plots to check the consistency of variance and the normality of errors
plot(aov(spotify$streams~spotify$released_day))
# There is a deviation from the line in the right side of the QQ plot.

# Box plot of streams ~ released_day
ggplot(spotify, aes(x=released_day, y=streams)) + 
  geom_boxplot(fill="honeydew", color="black",alpha=0.8) + 
  ggtitle("Box plot of streams by released day") + 
  theme_minimal()
```


```{r}
# streams ~ in_spotify_playlists + in_spotify_charts

ggplot(spotify, aes(x=in_spotify_playlists, y=streams, color=in_spotify_charts)) + 
  geom_point(size=2) + 
  ggtitle("Relation between Spotify and Streams") +
  scale_color_gradient(low = "palegreen", high = "black") +
  geom_smooth(method = "lm", linetype = "solid", color = "red", size=0.5) +
  geom_text(aes(label=ifelse(streams>3e+09 | in_spotify_playlists>45000, as.character(track_name), '')), hjust=0.5, vjust=1) +
  theme_minimal()
```


```{r}
# streams ~ in_apple_playlists + in_apple_charts

ggplot(spotify, aes(x=in_apple_playlists, y=streams, color=in_apple_charts)) + 
  geom_point(size=2) + 
  ggtitle("Relation between Apple Music and Streams") +
  scale_color_gradient(low = "palegreen", high = "black") +
  geom_smooth(method = "lm", linetype = "solid", color = "red", size=0.5) +
  geom_text(aes(label=ifelse(streams>3e+09 | in_apple_playlists>500, as.character(track_name), '')), hjust=0.5, vjust=1) +
  theme_minimal()
```


```{r}
# streams ~ in_deezer_playlists + in_deezer_charts

ggplot(spotify, aes(x=in_deezer_playlists, y=streams, color=in_deezer_charts)) + 
  geom_point(size=2) + 
  ggtitle("Relation between Deezer and Streams") +
  scale_color_gradient(low = "palegreen", high = "black") +
  geom_smooth(method = "lm", linetype = "solid", color = "red", size=0.5) +
  geom_text(aes(label=ifelse(streams>3e+09 | in_deezer_playlists>8000, as.character(track_name), '')), hjust=0.5, vjust=1) +
  theme_minimal()
```


```{r}
# streams ~ in_shazam_charts

ggplot(spotify, aes(x=in_shazam_charts, y=streams)) + 
  geom_point(size=2, color='black') + 
  ggtitle("Relation between Shazam and Streams") +
  geom_smooth(method = "lm", linetype = "solid", color = "red", size=0.5) +
  geom_text(aes(label=ifelse(in_shazam_charts>1250, as.character(track_name), '')), hjust=0.5, vjust=1) +
  theme_minimal()
```


```{r}
# streams ~ bpm

ggplot(spotify, aes(x=bpm, y=streams)) + 
  geom_point(size=2) + 
  ggtitle("Relation between BPM and Streams") +
  geom_smooth(method = "lm", linetype = "solid", color = "red", size=0.5) +
  theme_minimal()
```


```{r}
# streams ~ key + mode

ggplot(spotify, aes(x = factor(key), y = streams, fill = factor(mode))) +
  geom_boxplot() +
  scale_fill_manual(values = c("Major" = "honeydew", "Minor" = "honeydew3"), name = "Mode") +
  labs(title = "Streams based on Key and Mode", x = "Key", y = "Streams", fill = "Mode") +
  theme_minimal()
```


```{r}
# streams ~ danceability_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$danceability_perc)
lm_streams_danceability <- lm(streams~danceability_perc, data=spotify)
summary(lm_streams_danceability)
# The test is significant (p value < 0.05): variables are slightly negatively correlated.

# Scatter plot of streams ~ danceability_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=danceability_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of Danceability") +
  xlab("Percentage of danceability") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_danceability)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ valence_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$valence_perc)
lm_streams_valence <- lm(streams~valence_perc, data=spotify)
summary(lm_streams_valence)
# The test is not significant (p value > 0.05): variables are not correlated.

# Scatter plot of streams ~ valence_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=valence_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of valence") +
  xlab("Percentage of valence") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_valence)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ energy_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$energy_perc)
lm_streams_energy <- lm(streams~energy_perc, data=spotify)
summary(lm_streams_energy)
# The test is not significant (p value > 0.05): variables are not correlated.

# Scatter plot of streams ~ energy_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=energy_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of energy") +
  xlab("Percentage of energy") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_energy)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ acousticness_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$acousticness_perc)
lm_streams_acousticness <- lm(streams~acousticness_perc, data=spotify)
summary(lm_streams_acousticness)
# The test is not significant (p value > 0.05): variables are not correlated.

# Scatter plot of streams ~ acousticness_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=acousticness_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of acousticness") +
  xlab("Percentage of acousticness") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_acousticness)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ instrumentalness_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$instrumentalness_perc)
lm_streams_instrumentalness <- lm(streams~instrumentalness_perc, data=spotify)
summary(lm_streams_instrumentalness)
# The test is not significant (p value > 0.05): variables are not correlated

# Scatter plot of streams ~ instrumentalness_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=instrumentalness_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of instrumentalness") +
  xlab("Percentage of instrumentalness") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_instrumentalness)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ liveness_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$liveness_perc)
lm_streams_liveness <- lm(streams~liveness_perc, data=spotify)
summary(lm_streams_liveness)
# The test is not significant (p value > 0.05): variables are not correlated.

# Scatter plot of streams ~ liveness_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=liveness_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of liveness") +
  xlab("Percentage of liveness") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_liveness)
# There is a deviation from the line in the right side of the QQ plot.
```


```{r}
# streams ~ speechiness_perc

# numerical variable ~ numerical variable --> cor.test and lm
cor.test(spotify$streams,spotify$speechiness_perc)
lm_streams_speechiness <- lm(streams~speechiness_perc, data=spotify)
summary(lm_streams_speechiness)
# The test is significant (p value < 0.05): variables are slightly negatively correlated.

# Scatter plot of streams ~ speechiness_perc (highlighting the two main outliers)
ggplot(spotify, aes(x=speechiness_perc, y=streams)) +
  geom_point(color = dplyr::case_when(spotify$streams < 3e+09 ~ "black",
                                      spotify$streams > 3e+09 ~ "red")) +
  geom_text(aes(label=ifelse(streams>3e+09, as.character(track_name), '')), hjust=-0.1, vjust=0) +
  stat_smooth(method="lm", se=TRUE) +    
  ggtitle("Streams by Percentage of speechiness") +
  xlab("Percentage of speechiness") + 
  ylab("Streams")

# Checking the residuals
plot(lm_streams_speechiness)
# There is a deviation from the line in the right side of the QQ plot.
```

Correlation matrix of the song features. A heatmap on these correlations will be then displayed. 

```{r}
# Creating a data set with the relevant columns for the heatmap (features + streams)
features <- c('valence_perc', 'energy_perc', 'acousticness_perc', 'danceability_perc', 'instrumentalness_perc', 'liveness_perc', 'speechiness_perc', 'streams')
spotify_features <- spotify[features]

# Computing the correlation matrix
cor_matrix <- round(cor(spotify_features), 2)
cor_matrix

# Function to get the lower triangle of the correlation matrix (ref: http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization)
get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
}

# Function to get the upper triangle of the correlation matrix (ref: http://www.sthda.com/english/wiki/ggplot2-quick-correlation-matrix-heatmap-r-software-and-data-visualization)
get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
}

upper_tri <- get_upper_tri(cor_matrix)
upper_tri

# Creating the heatmap
#### NB: add the library(reshape2)
melted_cor_matrix <- melt(upper_tri, na.rm = TRUE)
ggplot(melted_cor_matrix, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile(color = "white") + 
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab", name = "Pearson's Correlation") + 
  geom_text(aes(Var1, Var2, label = value), color = "black", size = 3) +
  ggtitle("Correlation Heatmap of Song Features") + 
  xlab("Features") + 
  ylab("Features") + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  coord_fixed()
```


## 2.3 PCA (Principal Components Analysis)

```{r}
# Create a subset of numerical data (in_playlists, in_charts, and some features), excluding the variable streams
variables_pca <- c("in_spotify_playlists", "in_spotify_charts", "in_apple_playlists", "in_apple_charts", "in_deezer_playlists", "in_deezer_charts", "in_shazam_charts", "bpm", "danceability_perc", "valence_perc", "energy_perc", "acousticness_perc", "instrumentalness_perc", "liveness_perc", "speechiness_perc")
subset_pca <- spotify[, variables_pca]

# Standardize the data
scaled_pca <- scale(subset_pca)

# Apply PCA
pca_result <- prcomp(scaled_pca, center = TRUE, scale = TRUE)

# Extract principal components
PCs <- pca_result$x

# Create a DataFrame with the principal components
pc_columns <- paste("PC", 1:ncol(PCs), sep="")
df_pca <- as.data.frame(PCs)
names(df_pca) <- pc_columns

# Print the summary of PCA
summary(pca_result)

# Plot the cumulative explained variance
cum_exp_var <- cumsum(pca_result$sdev^2 / sum(pca_result$sdev^2))
plot(1:ncol(PCs), cum_exp_var, type="b", 
     xlab="Number of Principal Components", ylab="Cumulative Explained Variance") + abline(h = 0.8, col = "red", lty = 2)

# Explore the loadings and contributions of each variable to PCs
loadings <- pca_result$rotation
contributions <- loadings^2

print(loadings)
print(contributions)
```

```{r}
# Selecting the first 8 PCs
loadings_1_8 <- pca_result$rotation[, 1:8]

barplot(loadings_1_8, beside = TRUE, col = rainbow(ncol(scaled_pca)),
        names.arg = colnames(loadings_1_8), cex.names = 0.7,
        main = "Loadings for PCs 1 to 8", xlab = "Original Variables",
        ylab = "Loading Value")

# Add a legend
legend("topright", legend = colnames(scaled_pca), fill = rainbow(ncol(scaled_pca)), cex = 0.7)
```

```{r}
# Biplot PC1 vs PC2
biplot(
  pca_result,
  scale = 0,
  col = c('grey40','orange')
)
```


## 2.4 Centre-based Clustering (k-means)

```{r}
# Use the same standardized subset of data used before for the PCA
scaled_cluster <- scaled_pca

# Trying k-means with 4 groups
kmeans(scaled_cluster,centers = 4, iter.max = 100, nstart = 100)

# Define the optimal number of clusters
fviz_nbclust(scaled_cluster, kmeans, method = "silhouette")
fviz_cluster(kmeans(scaled_cluster, centers = 2, iter.max = 100, nstart = 100), data = scaled_cluster)
```

```{r}
# Clustering with k = 2
clusters <- kmeans(scaled_cluster, centers = 2, iter.max = 100, nstart = 100)

# Add the variable cluster to the original dataset
spotify <- spotify %>% 
  mutate(cluster = clusters$cluster)

# Plot the results
spotify %>%  
  ggplot(aes(x = in_spotify_playlists, y = streams, col = as.factor(cluster))) + 
  geom_point() + 
  labs(color = "Cluster") +
  ggtitle("Clusters for the variable in_spotify_playlists")

# Change the variable in_spotify_playlists with any other variable of the spotify_clusters dataset
```


# 3. Machine Learning Prediction

```{r}
set.seed(1234)
n_rows <- nrow(spotify)
training_idx <- sample(n_rows, n_rows * 0.70)
training_df <- spotify[training_idx,]
test_df <- spotify[-training_idx,]
```


```{r}
set.seed(1234)


rf.fit <- randomForest(streams ~ ., data = training_df, ntree = 500, importance = TRUE)

predictions <- predict(rf.fit, newdata = test_df)
actual_values <- test_df$streams

rmse <- rmse(test_df$streams, predictions)
rsq <- R2(pred = predictions, obs = test_df$streams)

rmse
rsq

```

```{r}
library(randomForest)

# Define a range of values for mtry to search over
mtry_values <- c(1:10)  # Adjust this range as needed

# Initialize variables to store results
rmse_values <- numeric(length(mtry_values))
rsq_values <- numeric(length(mtry_values))

# Perform grid search
for (i in seq_along(mtry_values)) {
  # Train Random Forest model with current value of mtry
  set.seed(1234)
  rf_model <- randomForest(streams ~ ., data = training_df, ntree = 500, mtry = mtry_values[i], importance = TRUE)
  
  # Make predictions on validation data
  predictions <- predict(rf_model, newdata = test_df)
  
  # Calculate RMSE
  rmse_values[i] <- sqrt(mean((test_df$streams - predictions)^2))
  
  # Calculate R-squared
  rsq_values[i] <- R2(pred = predictions, obs = test_df$streams)
}

# Find the index of the minimum RMSE
best_mtry_index <- which.min(rmse_values)
best_mtry <- mtry_values[best_mtry_index]

# Print the best mtry value and corresponding RMSE and R-squared
print(paste("Best mtry:", best_mtry))
print(paste("RMSE:", rmse_values[best_mtry_index]))
print(paste("R-squared:", rsq_values[best_mtry_index]))

```

```{r}
# Plot the R-squared values for each mtry
plot(mtry_values, rsq_values, type = "l", 
     xlab = "mtry", ylab = "R-squared", 
     main = "R-squared vs. mtry",
     xlim = c(min(mtry_values), max(mtry_values)))

# Add points at each mtry value
points(mtry_values, rsq_values, pch = 16, col = "blue")

# Add a vertical line at the best mtry value
abline(v = best_mtry, col = "red", lty = 2)

# Add text indicating the best mtry value
text(best_mtry, max(rsq_values), labels = paste("Best mtry:", best_mtry), pos = 3)

```


```{r}
ImpData <- as.data.frame(importance(rf.fit))
ImpData$Var.Names <- row.names(ImpData)

ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
  geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
  geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
  theme_light() +
  coord_flip() +
  theme(
    legend.position="bottom",
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  )

plot(rf.fit)
```



```{r}
formula_step2 <- as.formula(paste("streams ~ . - released_day - track_name - artist_name - released_month"))

# Rebuild the Random Forest model without 'track_name'
set.seed(1234)

rf_step2 <- randomForest(formula_step2, data = training_df, ntree = 500, importance = TRUE)

predictions_no_track <- predict(rf_step2, newdata = test_df)

rmse_no_track <- rmse(test_df$streams, predictions_no_track)
rsq_no_track <- R2(pred = predictions_no_track, obs = test_df$streams)

print(paste("Root Mean Squared Error (RMSE) on test data: ", rmse_no_track))
print(paste("R-squared (R2) on test data: ", rsq_no_track))
```

```{r}
ImpData <- as.data.frame(importance(rf_step2))
ImpData$Var.Names <- row.names(ImpData)

ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
  geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
  geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
  theme_light() +
  coord_flip() +
  theme(
    legend.position="bottom",
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  )
```





```{r}
library(randomForest)

# Define a range of values for mtry to search over
mtry_values <- c(1:10)  # Adjust this range as needed

# Initialize variables to store results
rmse_values <- numeric(length(mtry_values))
rsq_values <- numeric(length(mtry_values))

# Perform grid search
for (i in seq_along(mtry_values)) {
  # Train Random Forest model with current value of mtry
  set.seed(1234)
  rf_step3 <- randomForest(formula_step2, data = training_df, ntree = 500, mtry = mtry_values[i], importance = TRUE)
  
  # Make predictions on validation data
  predictions <- predict(rf_step3, newdata = test_df)
  
  # Calculate RMSE
  rmse_values[i] <- sqrt(mean((test_df$streams - predictions)^2))
  
  # Calculate R-squared
  rsq_values[i] <- R2(pred = predictions, obs = test_df$streams)
}

# Find the index of the minimum RMSE
best_mtry_index <- which.min(rmse_values)
best_mtry <- mtry_values[best_mtry_index]

# Print the best mtry value and corresponding RMSE and R-squared
print(paste("Best mtry:", best_mtry))
print(paste("RMSE:", rmse_values[best_mtry_index]))
print(paste("R-squared:", rsq_values[best_mtry_index]))

```



```{r}
# Plot the R-squared values for each mtry
plot(mtry_values, rsq_values, type = "l", 
     xlab = "mtry", ylab = "R-squared", 
     main = "R-squared vs. mtry",
     xlim = c(min(mtry_values), max(mtry_values)))

# Add points at each mtry value
points(mtry_values, rsq_values, pch = 16, col = "blue")

# Add a vertical line at the best mtry value
abline(v = best_mtry, col = "red", lty = 2)

# Add text indicating the best mtry value
text(best_mtry, max(rsq_values), labels = paste("Best mtry:", best_mtry), pos = 3)

```

```{r}

# Rebuild the Random Forest model without 'track_name'
set.seed(1234)

rf_step2 <- randomForest(formula_step2, data = training_df, ntree = 500, importance = TRUE, mtry=mtry_values[10])

predictions_no_track <- predict(rf_step2, newdata = test_df)

rmse_no_track <- rmse(test_df$streams, predictions_no_track)
rsq_no_track <- R2(pred = predictions_no_track, obs = test_df$streams)

print(paste("Root Mean Squared Error (RMSE) on test data: ", rmse_no_track))
print(paste("R-squared (R2) on test data: ", rsq_no_track))

```

```{r}
ImpData <- as.data.frame(importance(rf_step2))
ImpData$Var.Names <- row.names(ImpData)

ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
  geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
  geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
  theme_light() +
  coord_flip() +
  theme(
    legend.position="bottom",
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  )
```

```{r}
results <- data.frame(actual = test_df$streams, predicted = predictions_no_track)

# Plot the actual vs predicted values
ggplot(results, aes(x = actual, y = predicted)) +
  geom_point(color = "lightblue") +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +  # Add a reference line for perfect prediction
  labs(x = "Actual Streams", y = "Predicted Streams", title = "Actual vs Predicted Streams") +
  theme_bw()

summary(results)

```







Given the structure of the Spotify dataset, the columns artist_name, artist_count, released_year, released_month, released_day, key, and mode are candidates for one-hot encoding. However, treating released_year, released_month, and released_day as categorical might lead to a very high-dimensional dataset, especially with artist_name due to its potentially high cardinality.


```{r}

# 
numeric_columns <- sapply(spotify, is.numeric)
min_values <- lapply(spotify[numeric_columns], min, na.rm = TRUE)
max_values <- lapply(spotify[numeric_columns], max, na.rm = TRUE)

spotify_data_normalized <- spotify
spotify_data_normalized[numeric_columns] <- Map(function(x, min, max) { (x - min) / (max - min) }, spotify[numeric_columns], min_values, max_values)

```




```{r}
set.seed(1234) # For reproducibility
rows <- sample(nrow(spotify_data_normalized))
split <- round(nrow(spotify_data_normalized) * 0.7)
train_data <- spotify_data_normalized[rows[1:split], ]
test_data <- spotify_data_normalized[rows[(split + 1):nrow(spotify_data_normalized)], ]
```


```{r}
library(randomForest)
set.seed(1234)

training_start_time <- Sys.time()

rm.model <- randomForest(streams ~ ., data = train_data, ntree = 500, importance = TRUE)
rm.model

training_end_time <- Sys.time()
training_time <- training_end_time - training_start_time
training_time
```



```{r}
ImpData <- as.data.frame(importance(rm.model))
ImpData$Var.Names <- row.names(ImpData)

ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
  geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
  geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
  theme_light() +
  coord_flip() +
  theme(
    legend.position="bottom",
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  )
```



```{r}
predictions_normalized <- predict(rm.model, newdata = test_data)

streams_min <- min_values$streams[[1]]
streams_max <- max_values$streams[[1]]
predictions_denormalized <- predictions_normalized * (streams_max - streams_min) + streams_min

```


```{r}
rmse <- rmse(test_data$streams, predictions_denormalized)
rsq <- R2(pred = predictions_denormalized, obs = test_data$streams)

rmse
rsq
```


----------------------------------------------

```{r}
pca_data <- pca_result$x[, 1:8]

set.seed(1234)  # For reproducibility
train_indices <- sample(1:nrow(pca_data), size = floor(0.7 * nrow(pca_data)))
train_data <- pca_data[train_indices, ]
test_data <- pca_data[-train_indices, ]
train_target <- spotify$streams[train_indices]
test_target <- spotify$streams[-train_indices]

rf.fit3 <- randomForest(train_data, train_target, ntree = 500)
rf.fit3
```

```{r}
predictions <- predict(rf.fit3, newdata = test_data)

# Calculate RMSE and R-squared
rmse <- rmse(test_target, predictions)
rsq <- R2(pred = predictions, obs = test_target)

# Print RMSE and R-squared
print(paste("RMSE:", rmse))
print(paste("R-squared:", rsq))
```

-------------------------------------------------------------------------------------
```{r}
# One-hot encoding for selected categorical variables
categorical_cols <- c("artist_count", "key", "mode", "cluster")

# Perform one-hot encoding
spotify_data_encoded <- dummy_cols(spotify, select_columns = categorical_cols, remove_selected_columns = TRUE)

# Rename the column "key_A#" to "key_A_sharp"
colnames(spotify_data_encoded)[colnames(spotify_data_encoded) == "key_A#"] <- "key_A_sharp"
colnames(spotify_data_encoded)[colnames(spotify_data_encoded) == "key_C#"] <- "key_C_sharp"
colnames(spotify_data_encoded)[colnames(spotify_data_encoded) == "key_D#"] <- "key_D_sharp"
colnames(spotify_data_encoded)[colnames(spotify_data_encoded) == "key_F#"] <- "key_F_sharp"
colnames(spotify_data_encoded)[colnames(spotify_data_encoded) == "key_G#"] <- "key_G_sharp"

# Check the updated column names
colnames(spotify_data_encoded)


# View the structure of the encoded dataset
str(spotify_data_encoded)

```

```{r}
set.seed(1234) # For reproducibility
rows <- sample(nrow(spotify_data_encoded))
split <- round(nrow(spotify_data_encoded) * 0.7)
train_data <- spotify_data_encoded[rows[1:split], ]
test_data <- spotify_data_encoded[rows[(split + 1):nrow(spotify_data_encoded)], ]

training_start_time <- Sys.time()

rf.fit4 <- randomForest(formula_step2, data = train_data, ntree = 500, importance = TRUE, mtry=10)
rf.fit4

training_end_time <- Sys.time()
training_time <- training_end_time - training_start_time
training_time

predictions <- predict(rf.fit4, test_data)

rmse <- rmse(test_data$streams, predictions)
rsq <- R2(pred = predictions, obs = test_data$streams)

rmse
rsq
```
```{r}
ImpData <- as.data.frame(importance(rf.fit4))
ImpData$Var.Names <- row.names(ImpData)

ggplot(ImpData, aes(x=Var.Names, y=`%IncMSE`)) +
  geom_segment( aes(x=Var.Names, xend=Var.Names, y=0, yend=`%IncMSE`), color="skyblue") +
  geom_point(aes(size = IncNodePurity), color="blue", alpha=0.6) +
  theme_light() +
  coord_flip() +
  theme(
    legend.position="bottom",
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  )
```




```{r}
# write.csv(spotify, "spotify_cleaned.csv", row.names = FALSE)

# I needed this to extract cleaned data for HPCI technique
```

